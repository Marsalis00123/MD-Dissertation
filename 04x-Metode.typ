= Metodologia Studiului retrospectiv <metode>
== Populația de Studiu și Colectarea DatelorPopulația de Studiu și Colectarea Datelor
=== Criterii de Includere și Excludere

Criteriile de includere au fost concepute pentru a defini cu precizie populația de studiu. Acestea au cuprins: diagnosticul confirmat de spondilodiscită, validat prin metode imagistice avansate sau examinare histopatologică; vârsta adultă, definită ca fiind de 18 ani sau mai mult la momentul diagnosticului; existența unei documentații medicale comprehensive, incluzând rapoarte imagistice detaliate, note clinice complete și rezultate ale analizelor de laborator relevante; administrarea unui tratament specific pentru spondilodiscită, fie conservator, fie chirurgical; și încadrarea în perioada de studiu definită, respectiv pacienți externați între 1 ianuarie 2023 și 22 iulie 2024. Criteriile de includere și excludere sunt prezentate succint în @tbl-inc_exc.
#figure( 
  table(
  columns: (1fr, 1fr),
  inset: 8pt,
  align: left,
  
  table.header(
    [*Criterii de includere*], [*Criterii de excludere*]
  ),
  [Diagnosticul de spondilodiscită confirmat (IRM, CT, biopsie).],
  [Prezența bolilor concomitente ce pot interfera (ex: neoplasme vertebrale).],
  [Pacienți adulți, vârsta ≥ 18 ani.],
  [Fișe medicale incomplete sau lipsa documentației imagistice.],
  [Fișe medicale complete (imagistică, note clinice, analize).],
  [Pacienți cu vârsta < 18 ani.],
  [Tratament antibiotic sau chirurgical specific.],
  [Alergii la contrast sau contraindicații la IRM/CT (dispozitive implantate).],
  [Pacienți externați între 01.01.2023 - 22.07.2024.],
  [Pacienți care nu au urmat protocolul de tratament prescris.],
), kind: "table",
supplement: "Tabelul",
caption: "Criterii de includere și excludere pentru pacienții cu spondilodiscită incluși în studiu.",

) <tbl-inc_exc>



Aceste criterii de includere au fost stabilite pentru a asigura omogenitatea cohortei și validitatea concluziilor studiului. Limitarea vârstei la populația adultă recunoaște diferențele semnificative în prezentarea și managementul spondilodiscitei la copii comparativ cu adulții. Impunerea unei documentații medicale complete permite o evaluare holistică a fiecărui caz, în timp ce specificarea tratamentului țintit facilitează evaluarea eficacității diferitelor abordări terapeutice. Delimitarea temporală asigură o perspectivă contemporană asupra managementului spondilodiscitei.

În ceea ce privește criteriile de excludere, acestea au fost formulate pentru a elimina potențialele surse de bias și confuzie în interpretarea rezultatelor. Au fost excluși pacienții cu afecțiuni concomitente care ar fi putut interfera cu evaluarea precisă a spondilodiscitei, în special cei cu neoplasme vertebrale, dată fiind suprapunerea potențială a manifestărilor clinice și imagistice. De asemenea, au fost eliminați din studiu pacienții cu fișe medicale incomplete sau lipsite de documentație imagistică esențială, pentru a menține integritatea și acuratețea analizei datelor.

Deși a fost stabilit un criteriu de excludere pentru pacienții pediatrici, este important de menționat că baza de date a fost extrasă dintr-un spital de urgență pentru adulți, astfel încât nu au existat cazuri pediatrice în setul de date inițial. Acest criteriu a fost inclus pentru completitudinea metodologiei și pentru a asigura consistența cu practica standard în cercetarea clinică axată pe populația adultă. Au fost, de asemenea, excluși pacienții cu contraindicații absolute pentru IRM sau CT, incluzând alergii severe la agenții de contrast utilizați în aceste proceduri sau prezența dispozitivelor medicale implantate incompatibile cu câmpul magnetic al IRM-ului. Această excludere a fost implementată pentru a asigura siguranța pacienților și pentru a preveni potențialele complicații asociate procedurilor imagistice. În ceea ce privește aderența la tratament, pacienții incluși în studiu au aderat la tratamentul prescris pe parcursul internării. În cazurile de recidivă, s-a luat în considerare posibila aderență scăzută la tratament a pacienților după externare. Această abordare permite o evaluare mai nuanțată a eficacității tratamentului și a evoluției clinice, ținând cont atât de aderența în spital, cât și de posibilele variații în urmarea recomandărilor pe termen lung.

=== Colectarea datelor
Datele utilizate în prezentul studiu retrospectiv au fost colectate din baza de date a Spitalului Universitar de Urgență București. Identificarea pacienților eligibili, conform criteriilor de includere stabilite, s-a realizat prin căutarea în baza de date a spitalului utilizând codurile de diagnostic specifice pentru discită și spondilodiscită conform clasificării internaționale a bolilor (ICD-10). Codurile utilizate pentru filtrare au inclus: M46.43 - Discită, nespecificată, regiune toraco-cervicală; M46.44 - Discită, nespecificată, regiune toracică; M46.45 - Discită, nespecificată, regiune toraco-lombară; M46.46 - Discită, nespecificată, regiune lombară; și M46.47 - Discită, nespecificată, regiune lombo-sacrală.
Documentul primar utilizat pentru extracția datelor a fost fișa de externare a fiecărui pacient identificat. Din aceste fișe, datele relevante pentru obiectivele studiului au fost extrase manual. Variabilele specifice colectate au cuprins:

- Date demografice: identificator anonimizat, vârsta, genul.
- Date clinice: data internării, manifestările clinice la prezentare (prezentare), antecedente personale patologice (APP).
- Date paraclinice și de laborator: proteina C reactivă (CRP) (cu valoarea normală de referință 0 - 1 mg/dl), viteza de sedimentare a hematiilor (VSH) (valoare normală 5 - 10 mm/h), numărul total de leucocite (WBC) (valoare normală 3.6 - 11.8 x 10^3/µl).
- Date imagistice: modalitatea imagistică utilizată, segmentul spinal afectat, caracteristicile imagistice observate, utilizarea substanței de contrast.
- Date de diagnostic etiologic: efectuarea biopsiei (da/nu), rezultatul diagnosticului histopatologic, identificarea agentului patogen (agent inflamator).
- Date terapeutice și evoluție: tipul de tratament administrat (conservator sau chirurgical), detalii relevante despre protocolul operator (dacă este cazul), apariția complicațiilor, evoluția clinică pe parcursul internării, informații despre reevaluare sau recidivă menționate în fișa de externare (inclusiv exitus).
Datele au fost colectate pentru toți pacienții care au îndeplinit criteriile de includere și au fost externați din Spitalul Universitar de Urgență București în perioada 1 ianuarie 2023 – 22 iulie 2024.
== Metodele statistice 

// - fisher
// regresie liniară

=== Testul exact al lui Fisher
Testul exact Fisher este utilizat pentru a analiza independența dintre două variabile nominale, evaluând dacă proporțiile unei variabile diferă în funcție de valorile celeilalte variabile @HandbookBiologicalStatistics2014. Acesta este recomandat în special pentru eșantioane de dimensiuni mici, unde testul chi-pătrat nu se recomandă a fi folosit.

*Când se utilizează*:
Testul exact Fisher este adecvat atunci când se analizează două variabile categoriale și se dorește determinarea unei eventuale asocieri între ele. În contextul spondilodiscitelor, un exemplu de aplicare a testului exact Fisher este evaluarea relației dintre caracteristicile imagistice observate (precum prezența gadolinofiliei, eroziunilor, colecțiilor sau herniei de disc lombare) și decizia terapeutică (tratament chirurgical versus conservator). De exemplu, dacă un număr mai mare de pacienți cu colecții paraspinale au fost supuși intervenției chirurgicale comparativ cu cei fără această caracteristică imagistică, testul exact Fisher poate determina dacă această diferență este semnificativă statistic sau dacă este rezultatul variației aleatorii.

Tabelul de date utilizat în astfel de analize este cunoscut sub denumirea de tabel de contingență $R×C$ (rânduri $×$ coloane). Cea mai frecventă utilizare a testului exact Fisher este pentru tabele $2×2$, unde fiecare variabilă are câte două categorii (de exemplu, prezența sau absența unei caracteristici imagistice și tipul de tratament aplicat).

În cazul eșantioanelor mici, testul exact Fisher este preferabil testului chi-pătrat sau testului G, care pot oferi rezultate distorsionate atunci când frecvențele așteptate în celulele tabelului sunt mici. În general, testul exact Fisher este recomandat pentru seturi de date cu mai puțin de 1000 de observații.

*Ipoteza nulă*:
Ipoteza nulă a testului exact Fisher afirmă că proporțiile unei variabile sunt independente de valorile celeilalte variabile, adică distribuția unei caracteristici nu este influențată de cealaltă variabilă. 

*Modul de funcționare al testului*:
Spre deosebire de alte teste statistice care utilizează funcții matematice pentru a estima probabilitățile unor valori test-statistice, testul exact Fisher calculează direct probabilitatea de a obține datele observate (precum și toate seturile de date mai extreme), sub ipoteza nulă conform căreia proporțiile sunt egale. Această metodă permite o evaluare precisă a semnificației statistice, chiar și în cazul eșantioanelor mici, fără a se baza pe aproximări asimptotice .

=== Regresia liniară

Regresia liniară este o metodă statistică utilizată pentru a examina relația dintre două variabile cantitative, una independentă (predictor) și una dependentă (răspuns)@HandbookBiologicalStatistics2014. Aceasta permite evaluarea măsurii în care variațiile unei variabile sunt asociate cu modificările celeilalte și oferă un model matematic sub forma unei ecuații liniare de tipul:

$
Y = beta_0 + beta_1 X + epsilon
$

unde:
- $Y$ este variabila dependentă
- $X$ este variabila independentă
- $beta_0$ reprezintă interceptul (valoarea lui $Y$ atunci când $X=0$)
- $beta_1$ este panta dreptei de regresie, care indică rata de schimbare a lui $Y$ în raport cu $X$
- $epsilon$ este termenul de eroare, ce reflectă variațiile neexplicate de model

Regresia liniară poate fi utilizată atât pentru a testa ipoteze despre relația dintre variabile, cât și pentru a face predicții asupra unor valori necunoscute ale variabilei dependente.

==== Când se utilizează

Această metodă este folosită în situațiile în care se suspectează existența unei relații liniare între două variabile numerice. Exemple tipice includ: o variabilă biologică și un factor de risc sau, în contextul acestui studiu, numărul de investigații imagisticie în funcție de comorbiditățile pacienților.

==== Ipoteza nulă și ipoteza alternativă

În regresia liniară:
- Ipoteza nulă ($H_0$) presupune $beta_1 = 0$ (nu există relație semnificativă)
- Ipoteza alternativă ($H_1$) susține $beta_1 != 0$ (există relație semnificativă)

==== Cum funcționează testul

Metoda utilizează metoda celor mai mici pătrate pentru estimarea parametrilor. Indicatorii principali sunt:

- Coeficientul de determinare $R^2$:
  + Apropiat de 1 = relație puternică
  + Valori mici = asociere slabă

- Semnificația statistică se testează cu:
  + Analiza de varianță (ANOVA)
  + Valoarea $p$:
    * $p < 0.05$ → respingem $H_0$
    * $p >= 0.05$ → nu putem respinge $H_0$

// === Testul chi pătrat
// Testul Chi-Square pentru potrivirea distribuției este o metodă statistică utilizată pentru a determina dacă frecvențele observațiilor dintr-o variabilă nominală corespund unei distribuții teoretice predefinite. Acesta se aplică în cazul variabilelor nominale cu două sau mai multe categorii, iar interpretarea sa este validă în condițiile unui volum mare de date.

// În analiza corelației dintre caracteristicile imagistice și evoluția clinică, testul Chi-Square a fost utilizat pentru a evalua asocierea dintre distribuțiile observațiilor reale ale caracteristicilor imagistice și așteptările statistice. Acest test a permis compararea distribuțiilor observate cu cele teoretice pentru a determina dacă există o relație semnificativă între variabile.

// De exemplu, caracteristici precum „colecții” sau „amprentare medulară” au fost analizate din perspectiva frecvenței lor observate și a potențialelor asocieri cu evoluția clinică. Valorile p obținute au indicat gradul de concordanță dintre aceste caracteristici și evoluția pacienților, oferind o bază pentru concluziile statistice privind semnificația relațiilor evaluate.

// Pentru rezultate robuste, este esențial ca numărul așteptat de observații din fiecare categorie să fie suficient de mare. În caz contrar, testul Chi-Square poate fi inadecvat, iar metode alternative, cum ar fi testele exacte, pot fi preferate.

== Instrumente Software
Python este un limbaj de programare versatil și eficient, care a devenit din ce în ce mai important în domeniul analizei datelor medicale. Spre deosebire de software-urile comerciale, precum SPSS (Statistical Package for the Social Sciences), Python este un software gratuit și menținut de comunitate (FOSS - Free and Open Source Software). Acest aspect prezintă multiple avantaje pentru cercetătorii din domeniul medical.

În primul rând, Python poate fi utilizat fără costuri, ceea ce îl face accesibil pentru instituții de cercetare și spitale de toate dimensiunile. În al doilea rând, natura sa transparentă facilitează accesul la o comunitate vastă de dezvoltatori și cercetători, care contribuie constant la îmbunătățirea și extinderea capacităților sale. Această comunitate oferă, de asemenea, resurse bogate de învățare, ceea ce face ca Python să fie relativ ușor de învățat, chiar și pentru cei fără experiență anterioară în programare.

Python este utilizat pe scară largă în cercetarea medicală datorită vitezei sale de procesare și a capacităților sale extinse de analiză. Acesta include o bibliotecă standard robustă, care oferă funcționalități de bază pentru multe sarcini comune. În plus, prin intermediul platformei PyPI (Python Package Index), cercetătorii au acces la mii de module specializate. Aceste module permit efectuarea de analize statistice complexe, vizualizarea datelor și prelucrarea eficientă a seturilor mari de informații, toate fiind esențiale în cercetarea medicală modernă.

Deși SPSS rămâne o unealtă cunoscută și frecvent utilizată în cercetarea medicală, Python oferă o alternativă puternică și flexibilă. Principalele avantaje ale Python includ capacitatea sa de a se integra cu alte programe și de a rula pe orice platformă, fie că este vorba de Windows, MacOS sau Linux. Această versatilitate îl face ideal pentru cercetările colaborative și pentru proiectele care implică seturi mari de date și analize avansate, cum ar fi inteligența artificială sau procesarea imaginilor medicale.

Este important de menționat că Python poate efectua toate tipurile de analize statistice disponibile în SPSS, și chiar mai mult. Fiind un limbaj de programare complet, Python permite cercetătorilor să personalizeze și să optimizeze analizele în funcție de nevoile specifice ale studiului lor. Această flexibilitate este deosebit de valoroasă în cercetarea medicală, unde cerințele analitice pot varia semnificativ de la un studiu la altul.

În concluzie, deși tranziția de la software-uri statistice tradiționale la Python poate părea inițial dificilă, beneficiile pe termen lung în ceea ce privește flexibilitatea, costul și capacitățile analitice fac din Python o alegere excelentă pentru cercetătorii medicali care doresc să își îmbunătățească abilitățile de analiză a datelor.

=== Librării Software

==== Pandas

Pandas este o bibliotecă esențială în Python pentru manipularea și analiza datelor, folosită pe scară largă în cercetări medicale, economice, financiare și multe altele. Această bibliotecă oferă un obiect principal numit DataFrame, care este o structură de date, similară tabelelor din SPSS sau Excel, dar cu funcționalități mult mai avansate. Pandas permite manipularea rapidă și eficientă a datelor, inclusiv citirea și scrierea acestora în diverse formate, precum CSV, Excel și baze de date SQL.

Printre cele mai importante caracteristici ale Pandas se numără capacitatea de a gestiona seturi de date mari și complexe, oferind funcționalități avansate de indexare și subselectare a datelor pe baza etichetelor (label-based slicing). De asemenea, Pandas permite inserarea sau eliminarea de coloane din tabele în mod flexibil. O altă caracteristică importantă este alinierea automată a datelor, Pandas gestionând automat datele lipsă și aliniindu-le în funcție de etichetele de date, ceea ce face manipularea datelor neordonate mult mai simplă și organizată.

Pandas excelează în agregarea și transformarea datelor. Utilizând un motor puternic de _"group by"_, această bibliotecă permite gruparea, aplicarea de funcții și combinarea datelor cu ușurință, facilitând astfel procesele de agregare și transformare a datelor. În plus, Pandas oferă funcții de performanță înaltă pentru îmbinarea și fuziunea seturilor de date, un aspect esențial în studiile clinice care implică date provenite din surse multiple.

Pentru studiile medicale ce implică analize pe baza datelor cronologice, Pandas are funcționalități dedicate pentru generarea intervalelor de date, conversii de frecvență, precum și statistici în ferestre mobile (moving window statistics), utile în analizarea schimbărilor în timp. În ceea ce privește performanța, Pandas este optimizat pentru a rula rapid și eficient, având părți critice scrise în limbaje de programare de nivel inferior, ceea ce face ca analiza de date să fie rapidă chiar și pe seturi de date mari.

Pandas reprezintă alegerea ideală pentru medici și cercetători, oferind o soluție flexibilă, gratuită și open-source pentru analiza datelor reale, combinând puterea cu ușurința în utilizare. Este o unealtă excelentă pentru gestionarea datelor clinice, permițând analize statistice rapide și transformări complexe ale datelor din studiile medicale.

==== Matplotlib

Matplotlib @Hunter:2007 este o bibliotecă versatilă și puternică utilizată în Python pentru crearea vizualizărilor de date. Această bibliotecă oferă capacitatea de a genera reprezentări grafice statice, animate și interactive, fiind un instrument esențial pentru cercetătorii și medicii care doresc să analizeze și să comunice rezultatele studiilor clinice prin intermediul graficelor de înaltă calitate.

Unul dintre avantajele principale ale Matplotlib este capacitatea sa de a produce figuri de calitate publicațională în diverse formate, inclusiv PDF, PNG și SVG. Această caracteristică este deosebit de utilă pentru cercetătorii care doresc să includă vizualizări în articole științifice sau prezentări. 

Matplotlib excelează în crearea unei game largi de grafice personalizate. Acestea includ grafice de bare, grafice liniare, histograme și diagrame de dispersie, toate fiind instrumente esențiale pentru vizualizarea tendințelor și distribuțiilor în seturile de date medicale. De asemenea, biblioteca permite graficarea seriilor temporale, o funcționalitate crucială în analizele clinice longitudinale, unde este necesară urmărirea evoluției parametrilor medicali în timp.

O altă caracteristică importantă a Matplotlib este capacitatea de a crea subploturi și de a personaliza graficele. Această versatilitate face din Matplotlib un instrument ideal pentru prezentarea datelor complexe într-un mod clar și intuitiv.

În concluzie, Matplotlib se dovedește a fi un instrument extrem de util și adaptabil pentru comunitatea medicală și de cercetare. Biblioteca oferă posibilitatea de a crea rapid vizualizări pentru analiza exploratorie a datelor, precum și grafice complexe și rafinate pentru publicații științifice. Aceste caracteristici fac din Matplotlib o alegere excelentă pentru profesioniștii din domeniul medical care doresc să îmbunătățească calitatea și impactul vizual al prezentării rezultatelor lor de cercetare.

==== NumPy

NumPy reprezintă fundamentul calculului numeric în Python și este considerat standardul pentru manipularea array-urilor N-dimensionale rapide și versatile. În contextul cercetării medicale, NumPy joacă un rol esențial în manipularea și analiza seturilor mari de date, cum ar fi rezultatele experimentelor clinice sau datele provenite din imagistica medicală.

NumPy oferă o serie de funcționalități principale care îl fac indispensabil în analiza datelor medicale. În primul rând, array-urile N-dimensionale reprezintă structuri de date extrem de eficiente pentru stocarea și manipularea datelor numerice, permițând lucrul cu seturi complexe de informații, cum ar fi datele imagistice tridimensionale. Aceste array-uri facilitează organizarea și accesarea rapidă a informațiilor, aspect crucial în procesarea imaginilor medicale sau în analiza datelor provenite din studii clinice extensive.

În al doilea rând, NumPy pune la dispoziție o gamă completă de funcții matematice și statistice pentru analiza și prelucrarea datelor. Acestea includ rutine pentru algebră liniară, transformate Fourier și generatoare de numere aleatorii, toate fiind instrumente valoroase în modelarea statistică și simularea datelor clinice. Aceste funcționalități permit cercetătorilor să efectueze calcule complexe și să aplice metode statistice avansate pe seturile de date medicale, facilitând astfel interpretarea rezultatelor și identificarea pattern-urilor semnificative.

Datorită sintaxei sale accesibile și eficiente, NumPy se dovedește a fi un instrument valoros chiar și pentru cercetătorii cu experiență limitată în programare. Biblioteca oferă toate instrumentele necesare pentru analiza numerică și manipularea datelor medicale în studii complexe, facilitând astfel progresul în cercetarea medicală și îmbunătățirea procesului de luare a deciziilor clinice bazate pe date.

==== SciPy

SciPy reprezintă o componentă esențială în ecosistemul Python, fiind utilizată extensiv pentru rezolvarea unei game largi de probleme matematice și statistice complexe, cu o relevanță deosebită în domeniul cercetării medicale. Această bibliotecă extinde capabilitățile oferite de NumPy, furnizând instrumente suplimentare pentru efectuarea de calcule avansate pe array-uri și structuri de date specializate, cum ar fi matricele sparse și arborii k-dimensionali.

Principalele funcționalități oferite de SciPy includ optimizarea și integrarea, care sunt esențiale pentru ajustarea modelelor statistice și calculul funcțiilor complexe în analizele clinice. De asemenea, biblioteca oferă suport pentru interpolare și rezolvarea ecuațiilor diferențiale, funcționalități frecvent utilizate în modelarea datelor biologice sau clinice care implică schimbări în timp sau spațiu.
Un avantaj semnificativ al SciPy constă în sintaxa sa accesibilă și ușor de utilizat. Acest aspect face ca biblioteca să fie ideală pentru medici și cercetători care, deși pot avea o experiență limitată în programare, au nevoie de algoritmi puternici pentru a analiza și prelucra seturi complexe de date medicale. 


// == Reprezentarea vizuală a datelor și analiza statistică a cohortei studiate 

// Analiza statistică descriptivă a fost efectuată cu scopul de a caracteriza în detaliu cohorta de pacienți incluși în studiu, cu accent pe aspectele demografice, modalitățile imagistice utilizate și trăsăturile clinice relevante. Această abordare metodologică a fost concepută pentru a oferi o imagine comprehensivă și obiectivă asupra populației studiate, facilitând astfel o înțelegere aprofundată a distribuției caracteristicilor fundamentale ale pacienților și a corelațiilor potențiale între variabilele analizate, alegerea metodei terapeutice și rezultatele obținute.

// În cadrul analizei statistice, s-au luat în considerare următoarele variabile principale: vârsta și sexul pacienților, precum și modalitățile imagistice utilizate în procesul diagnostic. Pentru variabilele demografice, s-au efectuat calcule statistice descriptive precum, media aritmetică, mediana, deviația standard și intervalele de vârstă. Aceste calcule au fost realizate cu scopul de a reflecta cu acuratețe distribuția grupelor de vârstă și raportul între sexe în cohorta de pacienți studiată. În ceea ce privește modalitățile imagistice (IRM, CT, radiografie convențională, etc.), s-a calculat frecvența absolută și relativă de utilizare a fiecărei metode, precum și intervalele de încredere corespunzătoare, pentru a evalua cu precizie prevalența și importanța relativă a acestora în diagnosticarea spondilodiscitei.

// Pentru reprezentarea vizuală a datelor statistice, s-au folosit diverse metode grafice. Acestea includ diagrame cu coloane compozite, grafice radiale segmentate și histograme cu distribuții suprapuse. Aceste reprezentări grafice au fost concepute și optimizate pentru a ilustra în mod clar și comprehensiv distribuția modalităților imagistice utilizate, repartiția pe sexe, grupele de vârstă și tipurile de tratament aplicate (de exemplu, tratament chirurgical versus conservator). Fiecare reprezentare grafică a fost însoțită de legende detaliate și note explicative pentru a asigura o interpretare corectă și fără ambiguități. 

// === Documentație Python pentru Analiza Statisticilor Descriptive

// Această secvență de cod utilizează librăriile *pandas*, *matplotlib* și *numpy* pentru a analiza datele clinice ale cohortei de pacienți. Datele analizate includ vârsta, genul, metoda imagistică utilizată și abordarea terapeutică (chirurgicală vs. conservatoare). Analiza implică atât statistici descriptive, cât și vizualizări grafice sub formă de diagrame de bare și grafice circulare. Codul folosește un fișier CSV anonimizat ("_pacienti.csv_") care conține aceste date.
// ==== Biblioteci folosite:

// - *pandas* pentru manipularea și analiza datelor.
// - *matplotlib* pentru vizualizarea datelor (diagrame de bare și circulare).
// - *numpy* pentru operațiuni numerice suplimentare.

// ==== 1. Încărcarea datelor

// ```python
// import pandas as pd
// import matplotlib.pyplot as plt
// import numpy as np

// # Încărcarea datelor din fișierul CSV
// df = pd.read_csv('pacienti.csv')
// ```

// Codul încarcă setul de date utilizând funcția `pd.read_csv()`. Fișierul conține informații anonimizate despre pacienți.

// ==== 2. Statistici descriptive

// ==== a. Statistici legate de vârstă

// ```python
// # Statistici descriptive pentru vârstă
// age_stats = df['vârstă'].describe()
// print("Statistici vârstă:")
// print(age_stats)
// ```

// Această secțiune calculează și afișează statistici descriptive pentru variabila vârstă, incluzând media, mediana, și intervalele valorice.

// ==== b. Distribuția genurilor

// ```python
// # Distribuția genurilor
// gender_counts = df['gen'].value_counts()
// print("\nDistribuția genurilor:")
// print(gender_counts)
// ```

// Se calculează distribuția pacienților pe genuri, indicând numărul total de bărbați și femei în eșantion.

// ==== c. Frecvența modalităților imagistice

// ```python
// # Frecvența metodelor imagistice utilizate
// imaging_modalities = df['metodă imagistică'].str.split(', ', expand=True).stack().value_counts()
// print("\nFrecvența modalităților imagistice:")
// print(imaging_modalities)
// ```

// Această parte a codului analizează frecvența utilizării diferitelor metode imagistice (ex. IRM, CT), permițând analiza prevalenței fiecărei metode în diagnostic.

// ==== 3. Vizualizări grafice

// ==== a. Diagrama cu coloane pentru frecvența modalităților imagistice

// ```python
// # Bar plot pentru frecvența modalităților imagistice
// plt.figure(figsize=(10, 6))
// imaging_modalities.plot(kind='bar')
// plt.title('Frecvența modalităților imagistice')
// plt.xlabel('Modalitate imagistică')
// plt.ylabel('Frecvență')
// plt.xticks(rotation=45)
// plt.tight_layout()
// plt.savefig('imaging_modalities_bar.png')
// plt.close()
// ```

// Această secțiune creează o diagramă de bare care ilustrează frecvența fiecărei metode imagistice. Graficul este salvat într-un fișier PNG.

// ==== b. Diagrama radială pentru distribuția genurilor

// ```python
// # Diagrama radială pentru distribuția genurilor
// plt.figure(figsize=(8, 8))
// gender_counts.plot(kind='pie', autopct='%1.1f%%', startangle=90)
// plt.title('Distribuția genurilor')
// plt.axis('equal')
// plt.savefig('gender_distribution_pie.png')
// plt.close()
// ```

// Aceasta generează o diagramă circulară care arată distribuția procentuală a pacienților pe genuri. Diagrama este salvată într-un fișier PNG.

// ==== c. Diagrama cu coloane pentru abordarea terapeutică

// ```python
// # Bar plot pentru abordarea terapeutică (chirurgicală vs conservatoare)
// treatment_approach = df['tratament'].str.contains('chirurgical').map({True: 'Chirurgical', False: 'Conservator'}).value_counts()
// plt.figure(figsize=(8, 6))
// treatment_approach.plot(kind='bar')
// plt.title('Abordarea terapeutică')
// plt.xlabel('Tipul de tratament')
// plt.ylabel('Numărul de pacienți')
// plt.savefig('treatment_approach_bar.png')
// plt.close()
// ```

// Această parte creează o diagramă cu coloane pentru a ilustra numărul de pacienți care au urmat tratament chirurgical sau conservator, pe baza datelor din coloana "tratament". Rezultatul este salvat sub formă de imagine.

// === Documentație pentru analiza comorbidităților în cazul pacienților cu spondilodiscită

// Această secțiune detaliază metodologia și procesul de analiză statistică utilizate pentru evaluarea comorbidităților asociate pacienților diagnosticați cu spondilodiscită. Analiza are ca scop identificarea și cuantificarea celor mai frecvente afecțiuni concomitente, oferind astfel o perspectivă aprofundată asupra profilului clinic complex al acestor pacienți.

// ==== 1. Importarea bibliotecilor necesare

// Pentru realizarea analizei statistice, au fost utilizate următoarele biblioteci software specializate:

// ```python
// import pandas as pd  # Pentru gestionarea și analiza datelor tabelare
// import matplotlib.pyplot as plt  # Pentru crearea reprezentărilor grafice
// from collections import Counter  # Pentru cuantificarea frecvenței elementelor
// ```

// Fiecare dintre aceste biblioteci îndeplinește un rol specific în procesul de analiză:

// - *pandas*
// - *matplotlib*
// - *collections.Counter*: Asigură o metodă eficientă de numărare și clasificare a comorbidităților, facilitând identificarea celor mai frecvente afecțiuni asociate.

// ==== 2. Achiziția datelor clinice

// Setul de date utilizat în analiză a fost extras dintr-un fișier CSV anonim, conținând informații detaliate despre comorbidități pentru fiecare pacient diagnosticat cu spondilodiscită:

// ```python
// df = pd.read_csv('pacienți.csv')  # Încărcarea datelor din fișierul CSV anonim
// ```

// ==== 3. Implementarea funcției de extragere a comorbidităților

// Pentru a facilita procesarea datelor, a fost implementată o funcție specializată de extragere a comorbidităților din câmpurile text ale bazei de date:

// ```python
// def extract_comorbidities(s):
//     if pd.isna(s):  # Verificarea prezenței valorilor lipsă (NaN)
//         return []
//     return [c.strip() for c in s.split(',')]  # Segmentarea și normalizarea datelor textuale
// ```

// Această funcție asigură o procesare robustă a datelor, gestionând eficient atât cazurile cu multiple comorbidități, cât și situațiile în care informațiile sunt absente.

// ==== 4. Extragerea și agregarea comorbidităților

// Procesul de extragere și agregare a comorbidităților implică parcurgerea sistematică a fiecărei înregistrări din setul de date:

// ```python
// all_comorbidities = []
// for app in df['app']:
//     all_comorbidities.extend(extract_comorbidities(app))  # Compilarea unei liste comprehensive de comorbidități
// ```

// ==== 5. Cuantificarea frecvenței comorbidităților

// Pentru a determina prevalența fiecărei comorbidități în cohorta studiată, s-a utilizat funcționalitatea Counter din biblioteca collections:

// ```python
// comorbidity_counts = Counter(all_comorbidities)  # Cuantificarea frecvenței fiecărei comorbidități identificate
// ```

// ==== 6. Selecția și ordonarea comorbidităților principale

// În vederea focalizării analizei pe cele mai relevante comorbidități, s-a procedat la selecția și ordonarea descrescătoare a primelor 10 afecțiuni asociate:

// ```python
// top_10_comorbidities = dict(sorted(comorbidity_counts.items(), key=lambda x: x[1], reverse=True)[:10])
// ```

// ==== 7. Generarea reprezentării grafice

// Pentru vizualizarea clară și intuitivă a distribuției comorbidităților principale, s-a generat un grafic de tip bară utilizând biblioteca matplotlib:

// ```python
// plt.figure(figsize=(12, 6))  # Definirea dimensiunilor reprezentării grafice
// plt.bar(top_10_comorbidities.keys(), top_10_comorbidities.values())  # Construirea graficului de tip bară
// plt.title('Distribuția principalelor 10 comorbidități la pacienții cu spondilodiscită')  # Specificarea titlului graficului
// plt.xlabel('Comorbiditate')  # Etichetarea axei absciselor
// plt.ylabel('Frecvență')  # Etichetarea axei ordonatelor
// plt.xticks(rotation=45, ha='right')  # Ajustarea orientării etichetelor pentru optimizarea lizibilității
// plt.tight_layout()  # Optimizarea automată a dispunerii elementelor grafice
// ```

// ==== 8. Vizualizarea rezultatelor grafice

// Reprezentarea grafică generată este afișată pentru a facilita interpretarea vizuală a distribuției comorbidităților:

// ```python
// plt.show()  # Afișarea reprezentării grafice
// ```

// ==== 9. Prezentarea rezultatelor numerice

// Pentru o analiză detaliată, rezultatele sunt prezentate și sub formă tabelară, evidențiind frecvența absolută a fiecărei comorbidități principale:

// ```python
// print("Distribuția principalelor 10 comorbidități:")  # Titlul secțiunii de rezultate numerice
// for comorbidity, count in top_10_comorbidities.items():
//     print(f"{comorbidity}: {count}")  # Afișarea detaliată a fiecărei comorbidități și a frecvenței asociate
// ```

// Această metodologie de analiză oferă o perspectivă comprehensivă asupra profilului comorbidităților asociate pacienților cu spondilodiscită, facilitând astfel o înțelegere aprofundată a complexității clinice a acestei afecțiuni și potențialul impact asupra managementului terapeutic. Cu toate acestea s-au efectuat analize statistice suplimentare pentru a evalua corelațiile între comorbidități și numărul investigațiilor efetuate în funcție de acestea.
// ==== 10. *Importarea bibliotecilor necesare*

// Aceste biblioteci sunt folosite pentru analiza și manipularea datelor, precum și pentru efectuarea de regresii statistice.

// ```python
// import pandas as pd  # Gestionarea datelor tabelare
// import matplotlib.pyplot as plt  # Crearea graficelor
// import numpy as np  # Funcții matematice avansate
// from collections import Counter  # Numărarea elementelor
// from statsmodels.formula.api import poisson  # Modelul de regresie Poisson
// import statsmodels.api as sm  # Funcții pentru modele statistice

// ```

// ---

// ==== 11. *Citirea fișierului de date*

// Datele sunt citite din același fișier.

// ```python
// df = pd.read_csv('pacienți.csv')  # Citirea datelor din fișierul CSV

// ```

// ---

// ==== 12. *Funcție pentru extragerea comorbidităților și investigațiilor*

// Această funcție este utilizată pentru a extrage comorbiditățile și investigațiile din câmpurile text din fișier. Aceasta funcționează similar cu funcția anterioară pentru comorbidități.

// ```python
// def extract_items(s):
//     if pd.isna(s):  # Verificarea valorilor lipsă
//         return []
//     return [c.strip() for c in s.split(',')]  # Împarte textul și elimină spațiile extra

// ```

// ---

// ==== 13. *Extragerea comorbidităților și investigațiilor*

// Datele din coloanele de comorbidități (`app`) și investigații (`metodă imagistică`) sunt extrase și salvate în coloane noi.

// ```python
// df['comorbidities'] = df['app'].apply(extract_items)  # Extragerea comorbidităților
// df['investigations'] = df['metodă imagistică'].apply(extract_items)  # Extragerea investigațiilor

// ```

// ---

// ==== 14. *Numărarea investigațiilor pentru fiecare pacient*

// Se adaugă o nouă coloană care reprezintă numărul de investigații pentru fiecare pacient.

// ```python
// df['num_investigations'] = df['investigations'].apply(len)  # Numărarea investigațiilor

// ```

// ---

// ==== 15. *Selectarea celor mai comune 5 comorbidități*

// Se selectează cele mai frecvente 5 comorbidități din totalul comorbidităților.

// ```python
// all_comorbidities = [item for sublist in df['comorbidities'] for item in sublist]  # Lista totală a comorbidităților
// top_5_comorbidities = [x[0] for x in Counter(all_comorbidities).most_common(5)]  # Cele mai comune 5 comorbidități

// ```

// ---

// ==== 16. *Crearea variabilelor dummy pentru comorbidități*

// Se creează variabile "dummy" (0 sau 1) pentru fiecare din cele mai comune 5 comorbidități, indicând dacă un pacient are sau nu acea comorbiditate.

// ```python
// for comorbidity in top_5_comorbidities:
//     df[f'has_{comorbidity}'] = df['comorbidities'].apply(lambda x: comorbidity in x).astype(int)

// ```

// ---

// ==== 17. *Analiză descriptivă: Graficul distribuției investigațiilor*

// Se creează un grafic boxplot care ilustrează distribuția numărului de investigații în funcție de prezența fiecărei comorbidități din top 5.

// ```python
// plt.figure(figsize=(12, 6))  # Dimensiunea graficului
// df.boxplot(column='num_investigations', by=[f'has_{c}' for c in top_5_comorbidities])  # Crearea graficului
// plt.title('Distribuția numărului de investigații per comorbiditate')  # Titlul graficului
// plt.suptitle('')  # Eliminarea titlului suplimentar
// plt.ylabel('Număr de investigații')  # Eticheta axei Y
// plt.xticks(rotation=45, ha='right')  # Rotirea etichetelor pe axa X
// plt.tight_layout()  # Ajustarea automată a graficului
// plt.show()  # Afișarea graficului

// ```

// ---

// ==== 18. *Calcularea mediei investigațiilor per comorbiditate*

// Codul calculează media investigațiilor pentru pacienții care prezintă fiecare dintre cele 5 comorbidități și o afișează.

// ```python
// print("Media investigațiilor per comorbiditate:")  # Titlul secțiunii
// for comorbidity in top_5_comorbidities:
//     mean_investigations = df[df[f'has_{comorbidity}'] == 1]['num_investigations'].mean()  # Calcularea mediei
//     print(f"{comorbidity}: {mean_investigations:.2f}")  # Afișarea rezultatului

// ```

// ---

// ==== 19. *Pregătirea datelor pentru regresia Poisson*

// Variabilele dummy pentru comorbidități sunt folosite ca predictori, iar numărul de investigații este variabila dependentă.

// ```python
// X = df[[f'has_{c}' for c in top_5_comorbidities]]  # Variabilele predictor
// y = df['num_investigations']  # Variabila dependentă (numărul de investigații)
// X = sm.add_constant(X)  # Adăugarea unei constante pentru regresie

// ```

// ---

// ==== 20. *Regresia Poisson*

// Se aplică un model de regresie Poisson pentru a analiza legătura dintre prezența comorbidităților și numărul de investigații.

// ```python
// poisson_model = poisson('num_investigations ~ ' + ' + '.join([f'has_{c}' for c in top_5_comorbidities]), data=df).fit()

// ```

// ---

// ==== 21. *Afișarea rezultatelor regresiei*

// Rezultatele regresiei Poisson sunt afișate, inclusiv coeficienții și valorile statistice.

// ```python
// print("\\nRezultatele regresiei Poisson:")  # Titlul secțiunii
// print(poisson_model.summary())  # Afișarea rezultatelor

// ```

// ---

// ==== 22. *Interpretarea coeficienților*

// Se interpretează coeficienții modelului Poisson, arătând creșterea procentuală a numărului de investigații asociată fiecărei comorbidități.

// === Analiza impactului caracteristicilor imagistice asupra deciziei terapeutice în spondilodiscită

// Prezenta secțiune detaliază metodologia și procesul de analiză statistică utilizate pentru evaluarea relației dintre caracteristicile imagistice observate la pacienții cu spondilodiscită și abordarea terapeutică aleasă (chirurgicală sau conservatoare). Această analiză are ca scop identificarea potențialelor asocieri semnificative între aspectele imagistice specifice și decizia clinică privind modalitatea de tratament, oferind astfel o perspectivă aprofundată asupra factorilor care influențează managementul terapeutic al acestei afecțiuni.

// ==== 1. Implementarea instrumentelor de analiză statistică

// Pentru realizarea analizei statistice, au fost utilizate următoarele biblioteci software specializate:

// ```python
// import pandas as pd
// import matplotlib.pyplot as plt
// import seaborn as sns
// from scipy.stats import chi2_contingency, fisher_exact
// import numpy as np
// ```

// Fiecare dintre aceste biblioteci îndeplinește un rol specific în procesul de analiză:

// - *pandas*: Facilitează manipularea și analiza structurată a seturilor de date, permițând operațiuni complexe de filtrare, grupare și agregare a informațiilor clinice și imagistice.
// - *matplotlib și seaborn*: Aceste biblioteci sunt utilizate pentru generarea reprezentărilor grafice avansate, oferind o vizualizare clară și intuitivă a distribuțiilor și corelațiilor dintre variabilele analizate.
// - *scipy.stats*: Oferă funcționalități statistice avansate, incluzând testul Chi-Pătrat și testul exact Fisher,
// - *numpy*: Asigură suportul pentru operațiuni numerice de înaltă performanță, facilitând procesarea eficientă a datelor cantitative.

// === Biblioteci folosite:

// - *pandas:* pentru manipularea și analiza datelor.
// - *matplotlib:* pentru vizualizarea datelor (diagrame de bare și circulare).
// - *numpy:* pentru operațiuni numerice suplimentare.
// - *scipy.stats*: Oferă funcționalități statistice avansate, incluzând testul Chi-Pătrat și testul exact Fisher.

// ==== 2. Achiziția și preprocesarea datelor clinice

// Setul de date utilizat în analiză a fost extras dintr-un fișier CSV anonim, conținând informații detaliate despre caracteristicile imagistice și abordările terapeutice pentru fiecare pacient inclus în studiu:

// ```python
// df = pd.read_csv('pacienți.csv')
// ```

// Procesul de preprocesare a datelor a implicat crearea unor variabile binare pentru fiecare caracteristică imagistică relevantă, facilitând astfel analiza statistică ulterioară:

// ```python
// imaging_characteristics = ['eroziuni', 'tasări', 'edem', 'colecții', 'stenoză', 'amprentare_medulară', 'osteofite', 'deshidratări_discale', 'gadolinofilie', 'iodofilie', 'hdl', 'hemangioame', 'abces', 'fracturi', 'anterolistezis', 'cardiomegalie']

// for char in imaging_characteristics:
//     df[char] = df['caracteristici imagistice'].str.contains(char, case=False, na=False).astype(int)
// ```

// Această etapă de preprocesare a permis cuantificarea precisă a prezenței sau absenței fiecărei caracteristici imagistice pentru fiecare caz clinic analizat, creând astfel o bază solidă pentru analizele statistice ulterioare.

// ==== 3. Stratificarea abordărilor terapeutice

// Pentru a facilita analiza comparativă, pacienții au fost categorizați în funcție de tipul de tratament administrat, utilizând următoarea metodologie:

// ```python
// df['treatment_type'] = np.where(df['tratament'].str.contains('chirurgical', case=False, na=False), 'Chirurgical', 'Conservativ')
// ```

// Această categorizare binară a permis o evaluare clară a distribuției pacienților între abordările chirurgicale și cele conservative, oferind o bază solidă pentru analizele de asociere cu caracteristicile imagistice.

// ==== 4. Metodologia de analiză statistică

// Pentru evaluarea sistematică a relației dintre fiecare caracteristică imagistică și decizia terapeutică, a fost implementată o funcție de analiză specializată. Această funcție utilizează teste statistice riguroase pentru a determina semnificația asocierilor observate:

// ```python
// def analyze_characteristic(characteristic):
//     contingency_table = pd.crosstab(df[characteristic], df['treatment_type'])
//     # Implementarea testelor statistice și a vizualizărilor grafice
// ```

// Această abordare metodologică permite o evaluare comprehensivă și obiectivă a impactului fiecărei caracteristici imagistice asupra deciziei terapeutice, oferind astfel informații valoroase pentru optimizarea protocoalelor de management al spondilodiscitei.

// ==== 5. Analiza statistică și reprezentarea vizuală a datelor

// Această secțiune descrie metodologia detaliată a analizei statistice și a reprezentării vizuale a datelor, utilizând funcția `analyze_characteristic`. Această funcție este concepută pentru a examina relația dintre fiecare caracteristică imagistică și tipul de tratament administrat, oferind o analiză comprehensivă și riguroasă a datelor colectate.

// ==== 5.1. Generarea tabelei de contingență

// ```python
// contingency_table = pd.crosstab(df[characteristic], df['treatment_type'])
// ```

// Pentru fiecare caracteristică imagistică analizată, se generează o tabelă de contingență. Această tabelă reprezintă distribuția pacienților în funcție de prezența sau absența caracteristicii imagistice și tipul de tratament administrat (chirurgical sau conservator). Structura tabelei de contingență este următoarea:

// - Rândurile indică prezența (1) sau absența (0) caracteristicii imagistice analizate.
// - Coloanele reflectă distribuția pacienților în funcție de modalitatea terapeutică aleasă (chirurgicală sau conservatoare).

// ==== 5.2. Selecția și aplicarea testului statistic adecvat

// ```python
// if (contingency_table.values < 5).any():
//     _, p_value = fisher_exact(contingency_table)
//     test_type = "Test Exact Fisher"
// else:
//     _, p_value, _, _ = chi2_contingency(contingency_table)
//     test_type = "Testul Chi-Pătrat"
// ```

// Pentru a evalua semnificația statistică a asocierii dintre caracteristica imagistică analizată și tipul de tratament, se aplică unul din două teste statistice, în funcție de distribuția datelor:

// 1. *Testul Chi-Pătrat*: Acest test este utilizat pentru eșantioane de dimensiuni mari. Metodologia sa constă în compararea distribuției observate cu distribuția teoretică așteptată, oferind o evaluare robustă a asocierii dintre variabilele analizate.
// 2. *Testul Exact Fisher*: Acest test este aplicat în situațiile în care una sau mai multe celule din tabela de contingență conțin un număr de observații mai mic de 5. Testul Fisher oferă o precizie superioară în analiza eșantioanelor de dimensiuni reduse, asigurând astfel validitatea rezultatelor statistice în condițiile unor frecvențe celulare scăzute.

// ==== 5.3. Reprezentarea grafică a rezultatelor

// ```python
// plt.figure(figsize=(8, 6))
// sns.barplot(x=contingency_table.index, y=contingency_table.iloc[:, 0], color='blue', alpha=0.5, label='Conservator')
// sns.barplot(x=contingency_table.index, y=contingency_table.iloc[:, 1], color='red', alpha=0.5, label='Chirurgical')
// plt.title(f'{characteristic.capitalize()} vs Tipul de tratament')
// plt.xlabel(characteristic.capitalize())
// plt.ylabel('Număr de pacienți')
// plt.legend()
// plt.close()
// ```

// Pentru fiecare caracteristică imagistică analizată, se generează un grafic de tip bară, care oferă o reprezentare vizuală intuitivă a distribuției pacienților în funcție de prezența sau absența caracteristicii și tipul de tratament administrat. Elementele graficului includ:

// - Bare de culoare albastră, reprezentând pacienții care au beneficiat de tratament conservator.
// - Bare de culoare roșie, indicând pacienții care au fost supuși intervenției chirurgicale.

// Această reprezentare grafică facilitează interpretarea rapidă și eficientă a pattern-urilor de distribuție a pacienților între cele două modalități terapeutice, în raport cu prezența sau absența caracteristicii imagistice analizate.

// ==== 5.4. Structurarea și prezentarea rezultatelor statistice

// ```python
// return pd.DataFrame({
//     'Characteristic': [characteristic],
//     'Test Type': [test_type],
//     'p-value': [p_value],
//     'Significant': ['Da' if p_value < 0.05 else 'Nu']
// })
// ```

// Pentru fiecare caracteristică imagistică analizată, funcția generează un tabel de rezultate care sintetizează informațiile statistice relevante. Structura tabelului include următoarele elemente:

// - *Characteristic*: Denumirea caracteristicii imagistice supuse analizei.
// - *Test Type*: Specificarea testului statistic aplicat (Chi-Pătrat sau Fisher).
// - *p-value*: Valoarea p rezultată în urma aplicării testului statistic, indicând probabilitatea ca asocierea observată să fie rezultatul întâmplării.
// - *Significant*: Interpretarea semnificației statistice, bazată pe pragul convențional de 0.05. O valoare p inferioară acestui prag (p < 0.05) este considerată semnificativă statistic, sugerând existența unei asocieri între caracteristica imagistică și tipul de tratament administrat.

// ==== 6. Analiza globală și sinteza rezultatelor

// ```python
// results = pd.concat([analyze_characteristic(char) for char in imaging_characteristics])
// results = results.sort_values('p-value')
// print(results.to_string(index=False))
// ```

// Procesul de analiză este aplicat iterativ pentru toate caracteristicile imagistice incluse în studiu. Rezultatele individuale sunt agregate într-un tabel comprehensiv, care este ulterior ordonat ascendent în funcție de valoarea p. Această abordare permite identificarea rapidă a caracteristicilor imagistice cu cea mai puternică asociere statistică cu tipul de tratament administrat, facilitând astfel interpretarea și prioritizarea rezultatelor în contextul clinic.

// ==== 7. Exportul și arhivarea rezultatelor

// ```python
// # results.to_csv('statistical_test_results.csv', index=False)
// # plt.savefig(f'{characteristic}_barplot.png')
// ```

// Codul include opțiuni pentru exportul și arhivarea rezultatelor analizei, asigurând posibilitatea unei examinări ulterioare detaliate și a integrării în rapoarte sau prezentări științifice:

// - *Exportul rezultatelor statistice*: Tabelul final cu rezultatele analizei statistice poate fi exportat în format CSV, facilitând analize ulterioare sau integrarea în rapoarte comprehensive.
// - *Arhivarea reprezentărilor grafice*: Graficele generate pentru fiecare caracteristică imagistică pot fi salvate în format PNG, permițând includerea lor în prezentări sau publicații științifice.

// === Metodologia analizei statistice pentru asocierea caracteristicilor imagistice cu evoluția pacienților

// Prezenta secțiune detaliază metodologia utilizată pentru analiza statistică a relației dintre caracteristicile imagistice și evoluția pacienților, bazată pe un set de date medicale complex. Această abordare metodologică este concepută pentru a identifica și cuantifica asocierile semnificative statistic între prezența anumitor caracteristici imagistice și prognosticul pacienților, oferind astfel o bază solidă pentru interpretarea clinică și deciziile terapeutice ulterioare.

// ==== 1. Importul și pregătirea datelor

// Analiza debutează cu importul setului de date din fișierul 'anonim-clean.csv', utilizând biblioteca pandas. Acest fișier conține informații detaliate despre caracteristicile imagistice ale pacienților și evoluția lor clinică, codificată ca favorabilă sau nefavorabilă. Procesul de import este urmat de o etapă critică de preprocesare a datelor, care implică transformarea descrierilor textuale ale caracteristicilor imagistice în variabile binare cuantificabile.

// ```python
// import pandas as pd
// import numpy as np
// from scipy.stats import chi2_contingency, fisher_exact
// import matplotlib.pyplot as plt
// import seaborn as sns

// df = pd.read_csv('anonim-clean.csv')

// imaging_characteristics = ['eroziuni', 'tasări', 'edem', 'colecții', 'stenoză', 'amprentare_medulară', 'osteofite', 'deshidratări_discale', 'gadolinofilie', 'iodofilie', 'hdl', 'hemangioame', 'abces', 'fracturi', 'anterolistezis', 'cardiomegalie']

// for char in imaging_characteristics:
//     df[char] = df['caracteristici imagistice'].str.contains(char, case=False, na=False).astype(int)
// ```

// Acest proces de codificare binară permite o analiză statistică robustă, transformând descrierile calitative în date cantitative. Pentru fiecare caracteristică imagistică, se generează o coloană binară, unde valoarea 1 indică prezența caracteristicii, iar 0 absența acesteia.

// ==== 2. Definirea variabilei de evoluție

// Variabila dependentă, reprezentând evoluția pacienților, este codificată într-o nouă coloană binară denumită 'evolution_favorable'. Această codificare permite o analiză statistică mai precisă, diferențiind clar între evoluțiile favorabile și cele nefavorabile.

// ```python
// df['evolution_favorable'] = df['evoluție'].replace({'favorabilă': 1, 'lent_favorabilă': 1, 'nefavorabilă': 0, 'cerere': np.nan, 'sub_tratament': np.nan})

// df = df.dropna(subset=['evolution_favorable'])
// ```

// Codificarea atribuie valoarea 1 pentru evoluțiile favorabile și lent favorabile, și 0 pentru cele nefavorabile. Cazurile incerte sau incomplete (codificate ca 'cerere' sau 'sub_tratament') sunt excluse din analiză pentru a asigura acuratețea rezultatelor statistice.

// ==== 3. Analiza statistică și vizualizarea datelor

// Pentru fiecare caracteristică imagistică, se efectuează o analiză statistică riguroasă utilizând teste de independență. Alegerea între testul Chi-Pătrat și testul exact al lui Fisher se face în funcție de dimensiunea eșantionului pentru fiecare caracteristică, asigurând astfel validitatea statistică a rezultatelor.

// ```python
// def analyze_characteristic(characteristic):
//     contingency_table = pd.crosstab(df[characteristic], df['evolution_favorable'])

//     if (contingency_table.values &lt; 5).any():
//         _, p_value = fisher_exact(contingency_table)
//         test_type = "Fisher's exact test"
//     else:
//         _, p_value, _, _ = chi2_contingency(contingency_table)
//         test_type = "Chi-square test"

//     plt.figure(figsize=(8, 6))
//     sns.heatmap(contingency_table, annot=True, fmt='d', cmap='YlGnBu')
//     plt.title(f'{characteristic.capitalize()} vs Evolution')
//     plt.xlabel('Evolution (0: Unfavorable, 1: Favorable)')
//     plt.ylabel(f'{characteristic.capitalize()} (0: Absent, 1: Present)')
//     plt.savefig(f'{characteristic}_mosaic.png')
//     plt.close()

//     return pd.DataFrame({
//         'Characteristic': [characteristic],
//         'Test Type': [test_type],
//         'p-value': [p_value],
//         'Significant': ['Yes' if p_value &lt; 0.05 else 'No']
//     })
// ```

// Pentru fiecare caracteristică, se generează o tabelă de contingență și un grafic de tip mozaic, oferind o reprezentare vizuală intuitivă a distribuției pacienților în funcție de prezența caracteristicii și evoluția clinică. Aceste reprezentări grafice facilitează interpretarea rapidă a pattern-urilor de asociere între caracteristicile imagistice și prognosticul pacienților.

// ==== 4. Agregarea și interpretarea rezultatelor

// Rezultatele analizelor individuale sunt agregate într-un tabel comprehensiv, ordonat în funcție de valoarea p, permițând identificarea rapidă a caracteristicilor imagistice cu cea mai puternică asociere statistică cu evoluția pacienților.

// ```python
// results = pd.concat([analyze_characteristic(char) for char in imaging_characteristics])
// results = results.sort_values('p-value')
// print(results.to_string(index=False))

// results.to_csv('statistical_test_results_evolution.csv', index=False)

// plt.figure(figsize=(12, 6))
// sns.barplot(x='Characteristic', y='p-value', data=results)
// plt.xticks(rotation=45, ha='right')
// plt.axhline(y=0.05, color='r', linestyle='--')
// plt.title('P-values for Association between Imaging Characteristics and Evolution')
// plt.tight_layout()
// plt.savefig('p_values_plot.png')
// plt.close()
// ```

// Acest proces de agregare și vizualizare a rezultatelor facilitează interpretarea clinică a datelor, evidențiind caracteristicile imagistice cu potențial prognostic semnificativ. Graficul valorilor p oferă o perspectivă vizuală asupra semnificației statistice a fiecărei caracteristici, cu o linie de referință la p=0.05 pentru a delimita clar rezultatele semnificative statistic.

// ==== 5. Analiza frecvenței caracteristicilor imagistice

// În completarea analizei asociative, se realizează o evaluare a frecvenței absolute a fiecărei caracteristici imagistice în cohorta studiată. Această analiză oferă informații valoroase despre prevalența diferitelor trăsături imagistice în populația de pacienți examinată.

// ```python
// characteristic_frequencies = df[imaging_characteristics].sum().sort_values(ascending=False)
// print("\nFrequency of Imaging Characteristics:")
// print(characteristic_frequencies)

// plt.figure(figsize=(12, 6))
// characteristic_frequencies.plot(kind='bar')
// plt.title('Frequency of Imaging Characteristics')
// plt.xlabel('Characteristic')
// plt.ylabel('Frequency')
// plt.xticks(rotation=45, ha='right')
// plt.tight_layout()
// plt.savefig('characteristic_frequencies.png')
// plt.close()
// ```

// Reprezentarea grafică a frecvențelor caracteristicilor imagistice oferă o perspectivă complementară asupra datelor, permițând identificarea rapidă a trăsăturilor imagistice predominante în cohorta studiată. Această informație este crucială pentru interpretarea contextualizată a rezultatelor analizei asociative, facilitând o înțelegere mai nuanțată a relației dintre caracteristicile imagistice și evoluția clinică a pacienților.

// === Documentație pentru analiza statistică a segmentelor afectate și a tipului de tratament

// Această documentație explică analiza realizată asupra datelor medicale pentru a înțelege legătura dintre *segmentele afectate*, *tipul de tratament* (chirurgical sau conservativ), și *recidivă*. De asemenea, se efectuează o analiză de supraviețuire folosind metoda Kaplan-Meier pentru a evalua probabilitatea de recidivă în funcție de tratament.

// ==== 1. Importul bibliotecilor și încărcarea datelor

// ```python

// import pandas as pd
// import numpy as np
// from scipy.stats import chi2_contingency, fisher_exact, kruskal
// import matplotlib.pyplot as plt
// import seaborn as sns
// from lifelines import KaplanMeierFitter

// # Încărcarea datelor
// df = pd.read_csv('pacienți.csv')

// ```

// - *pandas* este folosit pentru manipularea datelor.
// - *scipy.stats* conține funcțiile pentru testele statistice (Chi-Pătrat, Fisher, Kruskal-Wallis).
// - *KaplanMeierFitter* din biblioteca *lifelines* este utilizat pentru analiza de supraviețuire.
// - *matplotlib* și *seaborn* sunt folosite pentru generarea graficelor.

// ==== 2. Preprocesarea datelor

// ```python

// df['treatment_type'] = np.where(df['tratament'].str.contains('chirurgical', case=False, na=False), 'Surgical', 'Conservative')
// df['recidivă'] = df['recidivă'].fillna(False).astype(bool)

// ```

// - *Tipul de tratament* este împărțit în *Chirurgical* și *Conservativ*, bazat pe informațiile din fișierul de date.
// - *Recidiva* este tratată ca o variabilă binară (adevărat sau fals), reprezentând dacă un pacient a avut sau nu recidivă.

// ==== 3. Segmente afectate

// ```python

// # Extragem toate segmentele unice afectate
// all_segments = df['segment'].str.split(',', expand=True).stack().str.strip().unique()

// # Creăm coloane binare pentru fiecare segment afectat
// for segment in all_segments:
//     df[f'segment_{segment}'] = df['segment'].str.contains(segment, case=False, na=False)

// ```

// Această secțiune extrage segmentele coloanei vertebrale afectate (cum ar fi *L1, L2, L3* etc.) și creează *coloane binare* pentru fiecare segment. Fiecare pacient va avea o valoare `True` (adevărat) dacă segmentul respectiv este afectat și `False` (fals) dacă nu este afectat.

// ==== 4. Test statistic pentru asocierea între segmentele afectate și tipul de tratament

// ```python

// def perform_statistical_test(data, var1, var2):
//     contingency_table = pd.crosstab(data[var1], data[var2])
//     if (contingency_table.values < 5).any():
//         _, p_value = fisher_exact(contingency_table)
//         test_type = "Fisher's exact test"
//     else:
//         _, p_value, _, _ = chi2_contingency(contingency_table)
//         test_type = "Chi-square test"
//     return test_type, p_value

// ```

// Se realizează un test statistic pentru a evalua dacă există o legătură semnificativă între *segmentul afectat* și *tipul de tratament*. Se folosește *Testul Chi-Pătrat* pentru eșantioane mari și *Testul Exact al lui Fisher* pentru eșantioane mici.

// ==== 4.1. Rezultate pentru segmente vs tipul de tratament

// ```python

// treatment_results = []
// for segment in segments:
//     test_type, p_value = perform_statistical_test(df, segment, 'treatment_type')
//     treatment_results.append({
//         'Segment': segment.replace('segment_', ''),
//         'Test Type': test_type,
//         'p-value': p_value,
//         'Significant': 'Yes' if p_value < 0.05 else 'No'
//     })

// treatment_results_df = pd.DataFrame(treatment_results)
// print("Segment vs Treatment Decision:")
// print(treatment_results_df.to_string(index=False))

// ```

// Pentru fiecare segment afectat, codul efectuează un test statistic pentru a verifica dacă segmentul este asociat cu un anumit tip de tratament (chirurgical sau conservativ). Rezultatele sunt prezentate într-un *tabel* care indică dacă asocierea este *semnificativă* statistic sau nu.

// ==== 5. Test statistic pentru recidivă

// ```python

// recurrence_results = []
// for segment in segments:
//     test_type, p_value = perform_statistical_test(df, segment, 'recidivă')
//     recurrence_results.append({
//         'Segment': segment.replace('segment_', ''),
//         'Test Type': test_type,
//         'p-value': p_value,
//         'Significant': 'Yes' if p_value < 0.05 else 'No'
//     })

// recurrence_results_df = pd.DataFrame(recurrence_results)
// print("\nSegment vs Recurrence Rate:")
// print(recurrence_results_df.to_string(index=False))

// ```

// Se aplică un test statistic similar pentru a evalua dacă un segment afectat este asociat cu o *recidivă* a bolii. Rezultatele indică segmentele care sunt asociate semnificativ cu o probabilitate mai mare de recidivă.

// ==== 6. Test Kruskal-Wallis pentru numărul de segmente afectate

// ```python

// df['num_segments'] = df['segment'].str.split(',').str.len()
// surgical = df[df['treatment_type'] == 'Surgical']['num_segments']
// conservative = df[df['treatment_type'] == 'Conservative']['num_segments']
// h_statistic, p_value = kruskal(surgical, conservative)

// print("\nKruskal-Wallis Test for Number of Affected Segments vs Treatment Type:")
// print(f"H-statistic: {h_statistic}")
// print(f"p-value: {p_value}")

// ```

// Testul *Kruskal-Wallis* este folosit pentru a compara numărul de segmente afectate între pacienții care au primit tratament chirurgical și cei cu tratament conservativ. Acest test ne spune dacă există o diferență semnificativă între aceste două grupuri.

// ==== 6.1. Vizualizarea numărului de segmente afectate

// ```python

// plt.figure(figsize=(10, 6))
// sns.boxplot(x='treatment_type', y='num_segments', data=df)
// plt.title('Number of Affected Segments vs Treatment Type')
// plt.savefig('segments_vs_treatment_boxplot.png')
// plt.show()

// ```

// Este generat un *grafic de tip boxplot* pentru a vizualiza distribuția numărului de segmente afectate în funcție de tipul de tratament. Acest grafic arată variația numărului de segmente afectate la pacienții care au primit tratament chirurgical comparativ cu cei care au primit tratament conservativ.

// ==== 7. Analiza Kaplan-Meier pentru probabilitatea de recidivă

// ```python
// kmf = KaplanMeierFitter()

// plt.figure(figsize=(10, 6))
// for treatment in df['treatment_type'].unique():
//     mask = df['treatment_type'] == treatment
//     kmf.fit(df[mask]['num_segments'], df[mask]['recidivă'], label=treatment)
//     kmf.plot()

// plt.title('Kaplan-Meier Estimate of Recurrence-Free Probability')
// plt.xlabel('Number of Affected Segments')
// plt.ylabel('Recurrence-Free Probability')
// plt.savefig('kaplan_meier_recurrence.png')
// plt.show()

// ```

// *Analiza Kaplan-Meier* este utilizată pentru a estima probabilitatea ca un pacient să rămână fără recidivă în funcție de numărul de segmente afectate și tipul de tratament. Aceasta permite vizualizarea supraviețuirii fără recidivă, comparând pacienții cu tratament chirurgical și conservativ.

// === Analiza complicațiilor post tratament

// ==== Documentație pentru codul Python - Model de Regresie Logistică pentru Prezicerea Complicațiilor

// Această documentație explică cum codul utilizează un model de regresie logistică pentru a prezice dacă pacienții vor dezvolta complicații în funcție de caracteristicile imagistice observate. De asemenea, se explică cum sunt interpretate rezultatele și cum se vizualizează importanța fiecărei caracteristici.

// ==== 1. Încărcarea și preprocesarea datelor

// ==== Bibliotecile folosite

// - *pandas*
// - *numpy*
// - *scikit-learn*
//     - *train_test_split*
//     - *LogisticRegression*
//     - *StandardScaler*
//     - *classification_report* și *confusion_matrix*
//         - Aceste funcții sunt folosite pentru evaluarea performanței modelului:
// - *matplotlib*
// - *seaborn*

// Codul încarcă datele și pregătește variabilele necesare pentru modelul de regresie logistică.

// ```python
// data = pd.read_csv('anonim-clean.csv')
// ```

// Se încarcă fișierul CSV cu datele pacienților, care include informații despre complicații și caracteristici imagistice.

// ```python
// # Crearea unei coloane binare pentru complicații
// data['complicatii_binare'] = data['complicații'].notnull().astype(int)

// ```

// - Se creează o coloană numită *`complicatii_binare`*, care indică dacă un pacient a avut complicații (`1`) sau nu (`0`).

// ```python
// # Extragerea caracteristicilor imagistice
// caracteristici = ['eroziuni', 'tasări', 'edem', 'colecții', 'stenoză', 'amprentare_medulară']

// ```

// - Sunt selectate caracteristicile imagistice relevante pentru analiza complicațiilor: *eroziuni, tasări, edem, colecții, stenoză și amprentare medulară*.

// ```python
// # Crearea variabilelor dummy pentru caracteristicile imagistice
// data['caracteristici imagistice'] = data['caracteristici imagistice'].fillna('')
// for carac in caracteristici:
//     data[carac] = data['caracteristici imagistice'].str.contains(carac).astype(int)

// ```

// - Fiecare caracteristică imagistică este transformată într-o *variabilă binară*: `1` dacă este prezentă la pacient și `0` dacă este absentă.

// ==== 2. Pregătirea datelor pentru modelul de regresie logistică

// ```python
// X = data[caracteristici]
// y = data['complicatii_binare']

// ```

// - *X* reprezintă datele de intrare (caracteristicile imagistice).
// - *y* reprezintă variabila țintă (complicații: `1` pentru prezență, `0` pentru absență).

// ```python
// # Împărțirea datelor în set de antrenament și set de test
// X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

// ```

// - Datele sunt împărțite în două seturi: *80% pentru antrenament* și *20% pentru testare*.

// ```python
// # Standardizarea caracteristicilor
// scaler = StandardScaler()
// X_train_scaled = scaler.fit_transform(X_train)
// X_test_scaled = scaler.transform(X_test)

// ```

// - Caracteristicile imagistice sunt *standardizate* pentru a asigura că toate variabilele au aceeași scară, ceea ce îmbunătățește performanța modelului.

// ==== 3. Antrenarea și evaluarea modelului de regresie logistică

// ```python
// # Antrenarea modelului de regresie logistică
// model = LogisticRegression(random_state=42)
// model.fit(X_train_scaled, y_train)

// ```

// Modelul de *regresie logistică* este antrenat pe setul de date de antrenament pentru a învăța cum să prezică prezența complicațiilor pe baza caracteristicilor imagistice.

// ```python
// # Predicții pe setul de test
// y_pred = model.predict(X_test_scaled)

// ```

// După antrenare, modelul face predicții pe setul de test pentru a evalua performanța sa.

// ==== 4. Evaluarea modelului

// ```python
// # Raport de clasificare
// print(classification_report(y_test, y_pred))

// ```

// *Raportul de clasificare* include informații despre acuratețea modelului în a prezice complicațiile. Acesta oferă măsuri cum ar fi *precizia*, *recall-ul* și *F1-score*, care descriu cât de bine modelul clasifică corect cazurile pozitive și negative.

// ```python
// # Matricea de confuzie
// cm = confusion_matrix(y_test, y_pred)
// plt.figure(figsize=(10,7))
// sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
// plt.title('Matricea de Confuzie')
// plt.ylabel('Adevărat')
// plt.xlabel('Prezis')
// plt.show()

// ```

// *Matricea de confuzie* arată cum sunt clasificate cazurile reale vs. cele prezise:

// - *Adevărat pozitiv*: Modelul a prezis corect prezența complicațiilor.
// - *Adevărat negativ*: Modelul a prezis corect absența complicațiilor.
// - *Fals pozitiv*: Modelul a prezis complicații când, de fapt, nu au fost.
// - *Fals negativ*: Modelul nu a prezis complicații, deși acestea au existat.

// ==== 5. Coeficienții modelului și importanța caracteristicilor

// ```python
// # Coeficienții modelului
// coef_df = pd.DataFrame({'Caracteristică': caracteristici, 'Coeficient': model.coef_[0]})
// coef_df = coef_df.sort_values('Coeficient', ascending=False)

// ```

// Fiecare caracteristică imagistică are un *coeficient* asociat, care indică influența sa asupra predicției complicațiilor:

// - Un *coeficient pozitiv* indică faptul că prezența acelei caracteristici crește probabilitatea de complicații.
// - Un *coeficient negativ* indică faptul că prezența acelei caracteristici scade probabilitatea de complicații.

// ```python
// # Vizualizarea importanței caracteristicilor
// plt.figure(figsize=(10,6))
// sns.barplot(x='Coeficient', y='Caracteristică', data=coef_df)
// plt.title('Importanța Caracteristicilor în Prezicerea Complicațiilor')
// plt.xlabel('Coeficient')
// plt.ylabel('Caracteristică')
// plt.show()

// ```

// Un grafic de tip *bară* vizualizează coeficienții pentru fiecare caracteristică, ajutând la înțelegerea importanței fiecărei variabile în prezicerea complicațiilor.

// ==== 6. Interpretarea rezultatelor

// ```python
// print("\\nInterpretarea coeficienților:")
// for index, row in coef_df.iterrows():
//     print(f"{row['Caracteristică']}: {row['Coeficient']:.4f}")
//     if row['Coeficient'] > 0:
//         print(f"  Prezența acestei caracteristici crește probabilitatea de complicații.")
//     else:
//         print(f"  Prezența acestei caracteristici scade probabilitatea de complicații.")
//     print()

// ```

// Pentru fiecare caracteristică, se oferă o interpretare clară:

// - Caracteristicile cu coeficienți pozitivi indică un risc crescut de complicații.
// - Caracteristicile cu coeficienți negativi indică un risc redus de complicații.